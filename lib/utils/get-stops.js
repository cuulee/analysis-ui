// @flow
import dbg from 'debug'
import bearing from '@turf/bearing'
import distance from '@turf/distance'
import {point} from '@turf/helpers'

import type {Segment, Stop} from '../types'

/**
 * Flow stops along a route. When autogenerating stops between bona fide stops,
 * how close can an autogenerated stop come to the next non-auto-generated stop,
 * as a fraction of stop spacing? TODO Make configurable?
 */
const MIN_SPACING_PERCENTAGE = 0.25

const debug = dbg('utils:get-stops')

export default function getStops (segments: Segment[]): Stop[] {
  if (segments.length === 0) return []
  if (segments.length === 1 && segments[0].geometry.type === 'Point') {
    const coord = segments[0].geometry.coordinates
    return [
      {
        center: coord,
        stopId: segments[0].fromStopId,
        index: 0,
        lat: coord[1],
        lon: coord[0],
        bearing: false, // this will hide directional icon, which is what we want
        autoCreated: !segments[0].stopAtStart,
        distanceFromStart: 0
      }
    ]
  }

  const stops = []
  const coord = segments[0].geometry.coordinates[0]
  stops.push({
    center: coord,
    stopId: segments[0].fromStopId,
    index: 0,
    lat: coord[1],
    lon: coord[0],
    bearing: bearing(point(coord), point(segments[0].geometry.coordinates[1])),
    autoCreated: !segments[0].stopAtStart,
    distanceFromStart: 0
  })

  // loop over the route, making stops as we go
  let distanceToLastStop = 0
  let distanceToLineSegmentStart = 0

  for (let segIdx = 0; segIdx < segments.length; segIdx++) {
    const segment = segments[segIdx]
    // now loop over line segments within this segment, accumulating distance as we go
    // a single transit segment can have multiple line segments, because we've used a street router between endpoints
    for (let i = 1; i < segment.geometry.coordinates.length; i++) {
      const c0 = segment.geometry.coordinates[i - 1]
      const c1 = segment.geometry.coordinates[i]
      const distanceThisLineSegment =
        distance(point(c0), point(c1), 'kilometers') * 1000

      // segment.spacing = 0 means no automatic stop creation in this segment
      while (
        segment.spacing > 0 &&
        distanceToLastStop + segment.spacing <
          distanceToLineSegmentStart + distanceThisLineSegment
      ) {
        // how far into the segment do we place the stop
        let frac =
          (distanceToLastStop + segment.spacing - distanceToLineSegmentStart) /
          distanceThisLineSegment
        if (frac < 0) frac = 0 // most likely the last segment did not have automatic stop creation

        const pos = [
          c0[0] + (c1[0] - c0[0]) * frac,
          c0[1] + (c1[1] - c0[1]) * frac
        ]

        // can't just add segment.spacing because of converting negative fractions to zero above
        // this can happen when the last segment did not have automatic stop creation, or had a larger spacing
        // TODO in the latter case, we probably want to continue to apply the spacing from the last line segment until we create a new stop?
        distanceToLastStop =
          distanceToLineSegmentStart + frac * distanceThisLineSegment

        stops.push({
          center: pos,
          stopId: null,
          index: segIdx,
          lat: pos[1],
          lon: pos[0],
          autoCreated: true,
          bearing: bearing(point(c0), point(c1)),
          distanceFromStart: distanceToLastStop
        })
      }

      distanceToLineSegmentStart += distanceThisLineSegment
    }

    if (segment.stopAtEnd) {
      const endCoord = segment.geometry.coordinates.slice(-1)[0]
      stops.push({
        center: endCoord,
        stopId: segment.toStopId,
        index: segIdx + 1,
        lat: endCoord[1],
        lon: endCoord[0],
        autoCreated: false,
        distanceFromStart: distanceToLineSegmentStart,
        bearing: segIdx < segments.length - 1
          ? bearing(
            point(segments[segIdx + 1].geometry.coordinates[0]),
            point(segments[segIdx + 1].geometry.coordinates[1])
          )
          : false
      })

      // restart the spacing
      distanceToLastStop = distanceToLineSegmentStart // distanceToLineSegmentStart already set to the start of the next line segment
    }
  }

  // filter out autocreated stops that are very close to bona fide stops
  return stops.filter((stop, stopIndex, stops) => {
    if (!stop.autoCreated) return true

    const spacingThisSegment = segments[stop.index].spacing
    if (spacingThisSegment === 0) {
      // fail harder?
      debug(
        `segment ${stop.index} contains auto-created stops but does not have automatic stop creation enabled?`
      )
      return true
    }

    // last stop
    if (stopIndex === stops.length - 1) return true

    // only need to check if it's too close to the next stop, as it will always be spaced away from the previous
    // stop, since we flow stops forward from the bona fide stops
    const nextStop = stops[stopIndex + 1]
    const delta = nextStop.distanceFromStart - stop.distanceFromStart
    const spacedCorrectlyFromNextStop =
      nextStop.autoCreated ||
      delta / spacingThisSegment >= MIN_SPACING_PERCENTAGE

    return spacedCorrectlyFromNextStop
  })
}
